### 1207

1. Найдём какую-нибудь угловую точку, например, точку с наименьшим y (если y равный, то по x).
2. Посчитаем угол, который составляет угловая точка с другими точками относительно одной из осей.
3. Отсортируем по углу.
4. Выберем среднюю точку.
5. Угловая и средняя точка — решение.
Так как по условию, то никакие 3 точки не лежат на одной прямой, а N чётная, то можно смело выбирать любую угловую точку и для неё же среднуюю.
Сложность n*logn

![](/images/3.png)

### 1322

Решением является алгоритм обратного преобразования Уилера-Барроуза. Основной идеей обратного преобразования является восстановление исходного состояния на этапе «сортировка строк». Заметим, что у нас есть весь набор символов, который мы можем отсортировать, потом добавить к отсортированной строке исходную, отсортировать и т. д. Но нам не нужны все строки, а только определенная, поэтому можно схитрить, отсортировать только один раз, а дальше смотреть по циклическим сдвигам.

1. Зададим каждой букве свой индекс
2. Рассмотрим исходное состояние на этапе «сортировка строк» и индексы у каждой строки

![](/images/4.png)

Как можем заметить, то всё циклически сдвинуто (алгоритм всё-таки основывается на циклических сдвигах). Так что нам достаточно один раз отсортировать и взять в таком порядке
str[row_number0] → str[row_number1] → …
где на каждой следующей итерации row_numberi = indexes[row_numberi-1]
Сложность n*logn

### 1444

1. Поставим начальную тыкву в точку отсчёта.
2. Переведём координаты в полярные.
3. Отсортируем по углу (если углы равные, то по радиусу).
4. Можно выводить.

![](/images/5.png)

5. Но может случится такое, что угол между соседними точками > 180 и такой угол только один (так как 360 градусов). В таком случае тропинки будут пересекаться.

![](/images/6.png)

6. Найдем такие точки. Выберем с наибольшим углом и начнём выводить тыквы, начиная с этой точки до n и с 0 до этой точки. Тогда мы исключим этот угол.
Сложность n*logn

### 1604

1. Отсортируем по количеству знаков, сохраняя индекс.
2. Будем выводить наибольшие знаки и наименьшие (правая и левая часть).
3. После каждого вывода упрощённая сортировка вставкой, чтобы столбец сместить и всегда справа были наибольшие столбцы.

![](/images/7.png)

![](/images/8.png)

Сложность n^2 (наибольшая), n*logn (наименьшая)

### 1726

Мы можем просто посчитать, сколько каждый человек проходит до каждого дома, но это n^2, что очень долго. Посчитаем за линию (хоть и сортировка потребует большего). Рассмотрим для начала одного человека, и сколько он проходит от своего дома до дома других.
И рассмотрим проекции его путей, допустим, на ось Oy (выделенно красным). Такие же пути будут проходить и другие жители, только количество будет другое. Так как все улицы перпендикулярны, то нам не важна зависимость между x и y, и их проекции мы можем считать отдельно. Отсортируем массив x-ов и y-ов. Тогда, чтобы посчитать расстояния sum(x) = (xi — xi-1) * i * (n-i) *2. Аналогично для y. Где i — количество жителей, на западе (или на севере) от тропинки, а n-i на востоке (или на севере) от тропинки. Умножаем на 2, так как с обратной стороны тоже ходят люди. Осталось только всё сложить и поделить на количество всевозможных тропинок (n-1)*n.
Сложность n*logn

![](/images/9.png)